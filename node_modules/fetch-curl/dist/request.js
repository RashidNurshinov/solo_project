"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_libcurl_1 = require("node-libcurl");
const urlLib = require("url");
const queryString = require("querystring");
const types_1 = require("./types");
class Request {
    constructor(url, options) {
        this.httpVersionMap = {
            "1": node_libcurl_1.CurlHttpVersion.V1_0,
            "1.1": node_libcurl_1.CurlHttpVersion.V1_1,
            "2": node_libcurl_1.CurlHttpVersion.V2_0
        };
        this._curl = new node_libcurl_1.Curl();
        this._options = options;
        this.setUrl(url);
        this.setMethod();
        this.setBody();
        this.setProxy();
        this.setFollowLocation();
        this.setHeaders();
        this.setVerbose();
        this.setHttpVersion();
        this.setTimeout();
        this.setOpts();
    }
    send() {
        return new Promise((resolve, reject) => {
            try {
                this._curl.on("end", (statusCode, body, headers) => {
                    try {
                        const response = new types_1.Response(this, statusCode, body, headers);
                        if (response.isRedirect(statusCode) &&
                            this.options.redirect == "error") {
                            reject(new types_1.FetchError(`redirect mode is set to error: ${response.url}`, "no-redirect"));
                        }
                        resolve(response);
                    }
                    catch (error) {
                        reject(new types_1.FetchError(error.message, "system", error));
                    }
                    finally {
                        this._curl.close();
                    }
                });
                this._curl.on("error", (error, errorCode) => {
                    this._curl.close();
                    reject(new types_1.FetchError(error.message, "curl-error", error, errorCode));
                });
                this._curl.perform();
            }
            catch (e) {
                reject(new types_1.FetchError(e.message, "fetch-curl-error", e));
            }
        });
    }
    get options() {
        return this._options;
    }
    get bodyString() {
        const { body } = this.options;
        if (typeof body === "string") {
            return body;
        }
        if (body == undefined) {
            return "";
        }
        const contentType = this.options.headers
            ? this.options.headers["content-type"]
            : "";
        if (contentType.includes("application/json")) {
            return JSON.stringify(body);
        }
        if (contentType.includes("application/x-www-form-urlencoded")) {
            return queryString.stringify(body);
        }
        return "";
    }
    get headerStringArray() {
        const headers = Object.assign(Object.assign({}, this.options.headers), this.defaultHeaders);
        return Object.entries(headers || []).map(header => {
            const [key, value] = header;
            return `${key}: ${value}`;
        });
    }
    get default() {
        return types_1.DefaulSetings;
    }
    get defaultHeaders() {
        const bodyString = this.bodyString;
        const bodyLenght = bodyString ? Buffer.byteLength(bodyString, "utf8") : 0;
        return { "content-length": bodyLenght };
    }
    setUrl(url) {
        if (!url) {
            throw new types_1.FetchError("Url missing", "url-missing");
        }
        this._curl.setOpt(node_libcurl_1.Curl.option.URL, url);
    }
    setMethod() {
        let { method } = this.options;
        method = method || this.default.method;
        if (method) {
            this._curl.setOpt(node_libcurl_1.Curl.option.CUSTOMREQUEST, method);
        }
    }
    setBody() {
        const { body } = this.options;
        if (!body) {
            return;
        }
        this._curl.setOpt(node_libcurl_1.Curl.option.POSTFIELDS, this.bodyString);
    }
    setProxy() {
        const { proxy } = this.options;
        if (!proxy) {
            return;
        }
        this._curl.setOpt(node_libcurl_1.Curl.option.PROXY, proxy);
        const parsedUrl = urlLib.parse(proxy);
        if (!parsedUrl.protocol) {
            throw new Error("Proxy protocol missing");
        }
        const proxyType = parsedUrl.protocol.replace(":", "");
        this._curl.setOpt(node_libcurl_1.Curl.option.PROXYTYPE, proxyType);
    }
    setFollowLocation() {
        let { redirect } = this.options;
        const alowRedirect = true;
        redirect = redirect || this.default.redirect;
        if (redirect && redirect === "manual") {
            this._curl.setOpt(node_libcurl_1.Curl.option.FOLLOWLOCATION, !alowRedirect);
        }
        if (redirect && redirect === "error") {
            this._curl.setOpt(node_libcurl_1.Curl.option.FOLLOWLOCATION, !alowRedirect);
            this._curl.setOpt(node_libcurl_1.Curl.option.MAXREDIRS, 0);
        }
        if (redirect && redirect === "follow") {
            const maxRedirects = this._options.follow || this.default.folow;
            this._curl.setOpt(node_libcurl_1.Curl.option.FOLLOWLOCATION, alowRedirect);
            this._curl.setOpt(node_libcurl_1.Curl.option.MAXREDIRS, maxRedirects);
        }
    }
    setHeaders() {
        const headersString = this.headerStringArray;
        this._curl.setOpt(node_libcurl_1.Curl.option.HTTPHEADER, headersString);
    }
    setVerbose() {
        const { curl } = this.options;
        if (!curl) {
            return;
        }
        const verbose = curl.verbose || this.default.verbose;
        this._curl.setOpt(node_libcurl_1.Curl.option.VERBOSE, verbose);
    }
    setHttpVersion() {
        let { version } = this.options;
        version = version || this.default.version;
        if (version) {
            this._curl.setOpt(node_libcurl_1.Curl.option.HTTP_VERSION, this.httpVersionMap[version]);
        }
    }
    setTimeout() {
        let { timeout } = this.options;
        timeout = timeout || this.default.timeout;
        if (timeout) {
            this._curl.setOpt(node_libcurl_1.Curl.option.TIMEOUT_MS, timeout);
        }
    }
    setOpts() {
        const { curl } = this.options;
        if (!curl) {
            return;
        }
        if (curl.opts) {
            for (const [option, value] of Object.entries(curl.opts)) {
                this._curl.setOpt(parseInt(option), value);
            }
        }
    }
}
exports.Request = Request;
//# sourceMappingURL=request.js.map